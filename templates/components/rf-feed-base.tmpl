{% define "content" %}
<link rel="import" href="/dist/iron-collapse/iron-collapse.html">
<link rel="import" href="/dist/iron-icon/iron-icon.html">
<link rel="import" href="/dist/iron-icons/iron-icons.html">
<link rel="import" href="/dist/iron-icons/hardware-icons.html">
<link rel="import" href="/dist/iron-icons/social-icons.html">
<link rel="import" href="/dist/iron-pages/iron-pages.html">
<link rel="import" href="/dist/iron-signals/iron-signals.html">
<link rel="import" href="/dist/more-routing/more-route-template-helpers.html">
<link rel="import" href="/dist/more-routing/more-routing.html">
<link rel="import" href="/dist/more-routing/more-routing.html">
<link rel="import" href="/dist/paper-fab/paper-fab.html">
<link rel="import" href="/dist/paper-icon-button/paper-icon-button.html">
<link rel="import" href="/dist/paper-input/paper-input.html">
<link rel="import" href="/dist/paper-item/paper-item.html">
<link rel="import" href="/dist/paper-menu-button/paper-menu-button.html">
<link rel="import" href="/dist/paper-menu/paper-menu.html">
<link rel="import" href="/dist/paper-ripple/paper-ripple.html">
<link rel="import" href="/dist/paper-spinner/paper-spinner.html">
<link rel="import" href="/dist/polymer/polymer.html">
<link rel="import" href="/dist/pushstate-anchor/pushstate-anchor.html">

<link rel="import" href="/component/rf-api">
<link rel="import" href="/component/rf-app-scaffold">
<link rel="import" href="/component/rf-feed">

<dom-module id="rf-feed-base">
    <style>
.drawer-menu a {
    color: var(--text-primary-color);
    text-decoration: none;
    min-height: 20px;
    font-size: 16px;

    @apply(--layout-horizontal);
    @apply(--layout-center);
}

.card {
    @apply(--card-style);
    @apply(--shadow-elevation-4dp);
    padding: 8px;
    margin-bottom: 16px;
}

.empty-list {
    font-family: "Roboto Slab";
    font-variant: small-caps;
    font-size: 2em;
    padding: 0.67em 2em;
}

.drawer-menu .submenu {
    margin-left: 16px;
}

.drawer-menu .submenu a {
    font-size: 14px;
}

.drawer-menu paper-icon-button.item {
    padding: 8px;
    margin-left: 4px;
}

rf-app-scaffold /deep/ .main-title-container paper-fab {
    position: fixed;
    right: 50px;
    top: 32px;
    z-index: 1;
    background: white;
}

rf-app-scaffold.update-available /deep/ .main-title-container paper-fab {
    background: var(--paper-fab-notify-background);
    color: var(--text-primary-color-inverse);
}

rf-app-scaffold /deep/ .main-title-container [route="feed"] {
    margin-top: -16px;
    margin-left: -8px;
    margin-bottom: -16px;
}
rf-app-scaffold /deep/ .main-title-container [route="article"] {
    margin-top: -8px;
    margin-left: -8px;
}

/deep/ .feed-favicon {
    margin-right: 5px;
}

rf-app-scaffold /deep/ [icon="arrow-back"] {
    margin-right: 24px;
}
    </style>
    <template>
        <rf-app-scaffold narrow="{{ narrow }}" class$="[[ _computeScaffoldClass(_updateAvailable) ]]">
            <div class="drawer-title">Feeds</div>
            <div class="drawer-menu">
                <div hidden$="[[  _computeHideFeedItems(feeds) ]]">
                    <a is="pushstate-anchor" href="[[ feedUrlFor('favorite') ]]" class="item">
                        <span>Favorite</span>
                        <paper-ripple></paper-ripple>
                    </a>

                    <div class="layout horizontal center">
                        <paper-icon-button icon="expand-more" expands="popular-feeds" class="item" on-tap="onToggleExpand"></paper-icon-button>
                        <a is="pushstate-anchor" href="[[ feedUrlFor('popular:all') ]]" class="layout horizontal flex">
                            <div style="position: relative" class="flex item">
                                Popular
                                <paper-ripple></paper-ripple>
                            </div>
                        </a>
                    </div>
                    <iron-collapse id="popular-feeds">
                        <div class="menu submenu">
                            <template is="dom-repeat" items="[[ tags ]]">
                                <a is="pushstate-anchor" href="[[ feedUrlFor(item.name, 'popular:tag') ]]" class="item">
                                    <span>[[ item.name ]]</span>
                                    <paper-ripple></paper-ripple>
                                </a>
                            </template>

                            <template is="dom-repeat" items="[[ feeds ]]">
                                <a is="pushstate-anchor" href="[[ feedUrlFor(item.Id, 'popular') ]]" class="item">
                                    <img src="[[ _computeFavIconUrl(item) ]]" alt="favicon" class="feed-favicon">
                                    <span>[[ item.Title ]]</span>
                                    <paper-ripple></paper-ripple>
                                </a>
                            </template>
                        </div>
                    </iron-collapse>
                    <hr>

                    <template is="dom-repeat" items="[[ _computeNavigationTags(tags) ]]">
                        <div class="layout horizontal center">
                            <paper-icon-button icon="expand-more" expands$="[[ _computeNavigationExpandTag(item) ]]" class="item" on-tap="onToggleExpand"></paper-icon-button>
                            <a is="pushstate-anchor" href="[[ repeaterTagUrl(item.name) ]]" class="layout horizontal flex">
                                <div style="position: relative" class="flex item">
                                    <span>[[ item.name ]]</span>
                                    <paper-ripple></paper-ripple>
                                </div>
                            </a>
                        </div>
                        <iron-collapse id="[[ _computeNavigationExpandTag(item) ]]">
                            <div class="menu submenu">
                                <template is="dom-repeat" items="[[ item.feeds ]]">
                                    <a is="pushstate-anchor" href="[[ feedUrlFor(item.Id) ]]" class="item">
                                        <img src="[[ _computeFavIconUrl(item) ]]" alt="favicon" class="feed-favicon">
                                        <span>[[ item.Title ]]</span>
                                        <paper-ripple></paper-ripple>
                                    </a>
                                </template>
                            </div>
                        </iron-collapse>

                    </template>
                    <hr>
                </div>
                <a is="pushstate-anchor" href="[[ urlFor('settings-general') ]]" class="item">
                    <span>Settings</span>
                    <paper-ripple></paper-ripple>
                </a>
                <a is="pushstate-anchor" href="[[ urlFor('logout') ]]" class="item">
                    <span>Logout</span>
                    <paper-ripple></paper-ripple>
                </a>
            </div>
            <div class="main-title">
                <more-route-selector>
                    <iron-pages>
                        <section route="feed" class="layout horizontal center flex">
                            <paper-icon-button icon="menu" paper-drawer-toggle></paper-icon-button>
                            <span class="title-text-feed flex" hidden$="[[ searchVisible ]]">
                                <paper-icon-button icon="arrow-back" style="visibility: hidden;" hidden$="[[ narrow ]]"></paper-icon-button>
                                <span>[[ _computeFeedTitle(tagOrId, feeds) ]]</span>
                            </span>
                            <span class="search-feed flex layout horizontal center" hidden$="[[ !searchVisible ]]">
                                <paper-icon-button icon="clear" on-tap="toggleSearch"></paper-icon-button>
                                <paper-input class="search-input" placeholder="Search" no-label-float on-keypress="onSearchKeypress" autofocus></paper-input>
                            </span>

                            <paper-icon-button icon="search" hidden$="[[ _computeHideSearchButton(tagOrId, searchVisible) ]]" on-tap="toggleSearch"></paper-icon-button>
                            <paper-menu-button horizontal-align="right">
                                <paper-icon-button icon="more-vert" class="dropdown-trigger"></paper-icon-button>
                                {%/* The second instance of the menu doesn't initialize its style correctly. Inline the background color */%}
                                <paper-menu class="dropdown-content options-menu" multi attr-for-selected="name" on-iron-activate="onFeedMenuItemActivate" style="background: #fff" selected-values="[[ _computeOptionsMenuSelectedValues(user.*) ]]">
                                    <paper-item name="newer-first">Newer first</paper-item>
                                    <paper-item name="unread-only">Unread only</paper-item>
                                    <paper-item name="mark-all-as-read">Mark all as read</paper-item>
                                </paper-menu>
                            </paper-menu-button>
                        </section>
                        <section route="article" class="layout horizontal center flex">
                            <paper-icon-button icon="arrow-back" on-tap="onArticleUp"></paper-icon-button>
                            <span class="title-text-article flex">[[ _computeFeedTitle(tagOrId, feeds) ]]</span>
                            <paper-icon-button icon="[[ _computeReadStateIcon(_readState) ]]" on-tap="onReadStateTap"></paper-icon-button>

                            <paper-icon-button icon="hardware:keyboard-arrow-left" style$="[[ _computeHideArticleArrow(_articleId, articles.splices, 'previous') ]]" on-tap="onPreviousArticle"></paper-icon-button>
                            <paper-icon-button icon="hardware:keyboard-arrow-right" style$="[[ _computeHideArticleArrow(_articleId, articles.splices, 'next') ]]" on-tap="onNextArticle"></paper-icon-button>

                            <paper-menu-button horizontal-align="right" hidden$="[[ !_shareServices.length ]]">
                                <paper-icon-button icon="social:share" class="dropdown-trigger"></paper-icon-button>
                                {%/* The second instance of the menu doesn't initialize its style correctly. Inline the background color */%}
                                <paper-menu class="dropdown-content options-menu" multi attr-for-selected="name" on-iron-activate="onShareServiceActivate" style="background: #fff">
                                    <template is="dom-repeat" items="[[ _shareServices ]]">
                                        <paper-item name="[[ item.name ]]">[[ item.description ]]</paper-item>
                                    </template>
                                </paper-menu>
                            </paper-menu-button>
                        </section>
                    </iron-pages>
                </more-route-selector>
                <paper-fab icon="refresh" on-tap="onRefresh" hidden$="[[ narrow ]]"></paper-fab>
            </div>
            <div class="main-content">
                <iron-scroll-threshold id="scroll-threshold" lower-threshold="100" on-lower-trigger="onLowerScrollThresholdTrigger"></iron-scroll-threshold>

                <rf-feed id="feed" user="[[ user ]]" feeds="[[ feeds ]]" articles="[[ articles ]]" narrow="[[ narrow ]]" tag-or-id="[[ tagOrId ]]" on-feed-article-state="onFeedArticleState"></rf-feed>

                <div class="card empty-list" hidden$="[[ _computeHideEmptyMessage(articles.*, loading) ]]">
                    <span>There are no articles in this section</span>
                </div>

                <div class="layout vertical center" hidden$="[[ !loading ]]">
                    <paper-spinner id="loading-spinner"></paper-spinner>
                </div>

            </div>
        </rf-app-scaffold>

        <rf-api id="list-feeds" method="list-feeds" on-rf-api-message="onAllFeedsMessage" user="{{ user }}"></rf-api>
        <rf-api id="user-settings" method="set-user-attribute" tag="feed-base" user="[[ user ]]"></rf-api>
        <rf-api id="feed-articles" method="get-feed-articles" args="[[ _computeFeedArticlesArguments(user.*, tagOrId, limit, offset) ]]" on-rf-api-message="onFeedArticlesMessage" user="[[ user ]]"></rf-api>
        <rf-api id="feed-read-all" method="mark-feed-as-read" on-rf-api-message="onFeedReadAllMessage" user="[[ user ]]"></rf-api>
        <rf-api id="feed-update-notifier" method="feed-update-notifier" on-rf-api-message="onFeedUpdateNotify" user="[[ user ]]" receiver="true"></rf-api>

        <iron-signals on-iron-signal-rf-feeds-added="onSignalFeedsChanged"></iron-signals>
        <iron-signals on-iron-signal-rf-feed-removed="onSignalFeedsChanged"></iron-signals>
        <iron-signals on-iron-signal-rf-feed-tags-changed="onSignalFeedTagsChanged"></iron-signals>
    </template>

    <script>
        "use strict";
        Polymer({
            is: "rf-feed-base",
            behaviors: [
                UserBehavior,
                NestedRouteBehavior,
                MoreRouting.TemplateHelpers,
            ],
            properties: {
                user: Object,
                tagOrId: {
                    type: String,
                    observer: '_tagOrIdChanged',
                },
                feeds: {
                    type: Array,
                    notify: true,
                    observer: '_feedsChanged',
                },
                articles: {
                    type: Array,
                    value: function() {
                        return this._createArticles();
                    },
                },
                loading: {
                    type: Boolean,
                    observer: '_loadingChanged',
                },
                tags: Array,
                searchVisible: {
                    type: Boolean,
                    value: false,
                },
                limit: {
                    type: Number,
                    value: 200,
                },
                offset: {
                    type: Number,
                    value: 0,
                },
                _articleId: String,
                _readState: Boolean,
                _shareServices: Array,
                _updateAvailable: {
                    type: Boolean,
                    value: false,
                },
            },
            observers: [
                '_userProfileChanged(user.ProfileData.*)',
            ],

            get _canAutoUpdate() {
                return !this._focused ||
                    !MoreRouting.isCurrentUrl('feed') ||
                    MoreRouting.isCurrentUrl('article') ||
                    new Date().getTime() - this._lastActivity > this._lastActivityDelay;
            },
            _lastUpdateTime: 0,
            _lastActivity: new Date().getTime(),
            _lastActivityDelay: 300000, // 5 minutes
            _focused: true,
            _urlParser: document.createElement('a'),

            _test: function(splices) {
                return "Splices " + splices;
            },

            feedUrlFor: function(tagOrId, prefix) {
                if (prefix) {
                    tagOrId = prefix + ":" + tagOrId;
                }
                return this.urlFor('feed', {tagOrId: tagOrId})
            },

            repeaterTagUrl: function(name) {
                if (name == 'All') {
                    return this.feedUrlFor('all');
                } else {
                    return this.feedUrlFor(name, 'tag');
                }
            },

            toggleSearch: function() {
                this.searchVisible = !this.searchVisible;
                if (this.searchVisible) {
                    // Get the currently active search input
                    var search = Polymer.dom(
                        Polymer.dom(this.root).querySelector('rf-app-scaffold').root
                    ).querySelector('.search-input');
                    if (search) {
                        search.$.input.focus();
                    }
                } else if (this.tagOrId.indexOf("search:") == 0) {
                    var tagOrId = this._extractSearchTokens(this.tagOrId)[0];
                    MoreRouting.navigateTo('feed', {tagOrId: tagOrId});
                }
            },

            refresh: function() {
                this.debounce('feed-refresh', function() {
                    this.loading = true;
                    this.noMoreArticles = false;
                    this.articles = this._createArticles();
                    this.offset = 0;
                    this.$['feed-articles'].send();
                });
            },

            ready: function() {
                this.$['list-feeds'].send();
            },

            attached: function() {
                this.defaultNestedRoute('feed-base', 'feed', {tagOrId: 'all'});

                this._appendArticleWorker = new Worker('/js/append-articles-worker.js');
                this._appendArticleWorker.addEventListener('message', this._handleArticleWorkerMessage.bind(this));

                this._shareServices = RfShareServices.getActive();

                this.$['scroll-threshold'].scrollTarget =
                    Polymer.dom(this.root).querySelector('rf-app-scaffold').mainScroller;

                window.addEventListener("focus", function() {this._focused = true}.bind(this), false);
                window.addEventListener("blur", function() {this._focused = false}.bind(this), false);

                document.addEventListener('keypress', this.onKeypress.bind(this), false);
                document.addEventListener('track', this.onTrack.bind(this), false);
                document.addEventListener('tap', this.onTrack.bind(this), false);

                // Set the property async, or it might be set too early for the template
                this.async(function() {
                    this.routeParamObserver('feed', 'tagOrId', function(value) {
                        if (value === null) {
                            return;
                        }

                        this.tagOrId = value;

                        if (value.indexOf("search:") == 0) {
                            this.searchVisible = true;
                            var term = this._extractSearchTokens(value)[1];

                            Polymer.dom(this.root).querySelectorAll('.search-input').forEach(function(input) {
                                input.value = term;
                            });
                        } else {
                            this.searchVisible = false;
                        }
                    }.bind(this));

                    this.routeParamObserver('article', 'articleId', function(value) {
                        if (value === null) {
                            return;
                        }

                        var article = this.articles.find(value);
                        this._articleId = value;
                        this.cancelDebouncer('article-read-state');
                        this._readState = article.Read;
                        this._ignoreReadDebouncer = false;
                        this._shareServices.forEach(function(service) {
                            service.article = article;
                        }.bind(this));
                    }.bind(this));
                });
            },

            onFeedArticleState: function(event, detail) {
                if ('Read' in detail) {
                    if (this._ignoreReadDebouncer) {
                        this._readState = detail.Read;
                        this._ignoreReadDebouncer = false;
                    } else {
                        this.debounce('article-read-state', function() {
                            this._readState = detail.Read;
                        }, 1000);
                    }
                }
            },

            onAllFeedsMessage: function(event, detail) {
                this.feeds = detail.arguments.Feeds;
            },

            onFeedArticlesMessage: function(event, data) {
                this._updateAvailable = false;
                if (data.arguments.Articles && data.arguments.Articles.length) {
                    var data = {
                        current: [].concat(this.articles),
                        newArticles: data.arguments.Articles,
                        unshiftFirst: this.articles.length && data.arguments.Offset == 0,
                    };

                    if (isNaN(this.tagOrId)) {
                        data.feeds = this.feeds;
                    }

                    this._appendArticleWorker.postMessage(data);
                } else {
                    this.noMoreArticles = true;
                    this.loading = false;

                    if (!this.offset) {
                        this.articles = this._createArticles();
                    }
                }
                this._lastUpdateTime = new Date().getTime();
            },

            onFeedReadAllMessage: function(event, data) {
                if (data.success) {
                    for (var i = 0, a; a = this.articles[i]; ++i) {
                        this.set("articles." + i + ".Read", true);
                    }
                }
            },

            onFeedUpdateNotify: function(event, data) {
                var updateAvailable = false;
               
                if (this.tagOrId.indexOf("tag:") == 0) {
                    var tag = this.tagOrId.substring(4),
                        active = this.feeds.filter(function(feed) {
                            return feed.Tags && feed.Tags.indexOf(tag) != -1 
                        });

                    if (active.some(function(feed) { return feed.Id == data.arguments.Feed.Id })) {
                        updateAvailable = true;
                    }

                } else if (this.tagOrId == "all" || this.tagOrId == data.arguments.Feed.Id) {
                    updateAvailable = true;
                }

                if (!updateAvailable) {
                    return;
                }

                this._updateAvailable = true;
                if (this._canAutoUpdate) {
                    // Give the thumbnailer some time to gather any thumbnails
                    this.debounce('auto-update-timeout',
                        this._updateArticles, 30000); // 30s
                }
            },

            onSignalFeedsChanged: function() {
                this.$['list-feeds'].send();
            },

            onSignalFeedTagsChanged: function(event, detail) {
                for (var i = 0, f; f = this.feeds[i]; ++i) {
                    if (f.Id == detail.Id) {
                        f.Tags = detail.Tags;

                        this._updateTags();
                        this.set('feeds.' + i, f);
                    }
                }
            },

            onToggleExpand: function(event) {
                var element = Polymer.dom(event).localTarget;

                var collapser = Polymer.dom(this.root).querySelector(
                        '#' + element.getAttribute('expands'));

                if ('icon' in element) {
                    element.icon = collapser.opened ? 'expand-more' : 'expand-less';
                }
                collapser.toggle();
            },

            onArticleUp: function() {
                MoreRouting.navigateTo('feed', {tagOrId: MoreRouting.getRoute('feed').params.tagOrId});
            },

            onReadStateTap: function(event) {
                var element = Polymer.dom(event).localTarget;

                this._ignoreReadDebouncer = true;
                this.flushDebouncer('article-read-state');
                this.$.feed.articleState(this._articleId,
                    {Read: !this.articles.find(this._articleId).Read});
            },

            onPreviousArticle: function() {
                this._previousArticle();
            },

            onNextArticle: function() {
                this._nextArticle();
            },

            onRefresh: function() {
                MoreRouting.navigateTo('feed', {tagOrId: MoreRouting.getRoute('feed').params.tagOrId});
                this.refresh();
            },

            onFeedMenuItemActivate: function(event) {
                // Event is fired before the actual selection takes place
                var menu = Polymer.dom(event).localTarget,
                    name = event.detail.selected,
                    selected = (menu.selectedValues || []).indexOf(name) == -1;

                switch (name) {
                case "newer-first":
                    this.set("user.ProfileData.newerFirst", selected)
                    this.refresh();
                    break;
                case "unread-only":
                    this.set("user.ProfileData.unreadOnly", selected)
                    this.refresh();
                    break;
                case "mark-all-as-read":
                    if (selected) {
                        menu.select(name);
                    }
                    this.$._markAllAsRead();
                    break;
                }
            },

            onShareServiceActivate: function(event) {
                var menu = Polymer.dom(event).localTarget,
                    name = event.detail.selected,
                    selected = (menu.selectedValues || []).indexOf(name) == -1;

                if (selected) {
                    menu.select(name);
                    window.open(RfShareServices.get(name).url, '_blank');
                }
            },

            onKeypress: function(event) {
                if (!MoreRouting.isCurrentUrl('feed-base')) {
                    return;
                }

                var code = event.keyCode || event.charCode,
                    articleRoute = MoreRouting.getRouteByName('article');

                switch (code) {
                    case 74: // J
                    case 106: // j
                        this._nextArticle(event.shiftKey);
                        break;
                    case 75: // K
                    case 107: // k
                        this._previousArticle(event.shiftKey);
                        break;
                    case 72: // H
                    case 104: // h
                        MoreRouting.navigateTo('feed', {tagOrId: this.tagOrId});
                        break;
                    case 82: // R
                    case 114: // r
                        this.refresh();
                        break;
                    case 47:
                        if (!this._searchAvailable(this.tagOrId) || this.searchVisible) {
                            return;
                        }

                        this.toggleSearch();
                        break;
                }

                this._lastActivity = new Date().getTime();
                this.debounce('last-activity-timeout',
                    this._updateArticles, this._lastActivityDelay);
            },

            onTrack: function(event) {
                if (!MoreRouting.isCurrentUrl('feed')) {
                    return;
                }

                this._lastActivity = new Date().getTime();
                this.debounce('last-activity-timeout',
                    this._updateArticles, this._lastActivityDelay);
            },

            onSearchKeypress: function(event) {
                var code = event.keyCode || event.charCode, key = event.keyIdentifier,
                    target = Polymer.dom(event).localTarget;

                if (key == 'Enter' || code == 13) {
                    MoreRouting.navigateTo('feed', {
                        tagOrId: "search:" + this._extractSearchTokens(this.tagOrId)[0] + ":" + target.value,
                    });
                }

                event.stopPropagation();
            },

            onLowerScrollThresholdTrigger: function(event) {
                if (this.noMoreArticles || MoreRouting.isCurrentUrl('article') || this.loading) {
                    return;
                }
                this.debounce('feed-refresh', function() {
                    this.loading = true;
                    this.offset += this.limit;
                    this.$['feed-articles'].send();
                });
            },

            _tagOrIdChanged: function(tagOrId, oldValue) {
                this.refresh();
            },

            _feedsChanged: function(newValue, oldValue) {
                this._updateTags();
            },

            _loadingChanged: function(loading, old) {
                if (loading) {
                    this.$['loading-spinner'].reset();
                    this.$['loading-spinner'].active = true;
                } else {
                    this.$['loading-spinner'].active = false;
                }
            },

            _userProfileChanged: function(userProfileRecord) {
                if (this.user) {
                    this.$['user-settings'].send({
                        attribute: "ProfileData",
                        value: this.user.ProfileData
                    });
                }
            },

            _computeScaffoldClass: function(updateAvailable) {
                return updateAvailable ? 'update-available' : '';
            },

            _computeFeedTitle: function(tagOrId) {
                if (tagOrId == "all") {
                    return "All feed articles";
                } else if (tagOrId == "favorite") {
                    return "Favorite feed articles";
                } else if (tagOrId.indexOf("popular:") == 0) {
                    var sub = tagOrId.substring("popular:".length);

                    if (sub == "all") {
                        return "Popular feed articles";
                    } else if (sub.indexOf("tag:") == 0) {
                        return "Popular articles from " + tagOrId.substring("tag:".length);
                    } else if (!isNaN(sub)) {
                        var feed = this.feeds.filter(function(f) { return f.Id == sub })[0];
                        if (feed) {
                            return "Popular articles from " + feed.Title;
                        }
                    }
                } else if (tagOrId.indexOf("search:") == 0) {
                    var parts = this._extractSearchTokens(tagOrId),
                        sub = parts[0],
                        term = parts[1],
                        base = "Search results for " + term;;

                    if (sub == "all") {
                        return base;
                    } else if (sub.indexOf("tag:") == 0) {
                        return base + "  from " + tagOrId.substring("tag:".length);
                    } else if (!isNaN(sub)) {
                        var feed = this.feeds.filter(function(f) { return f.Id == sub })[0];
                        if (feed) {
                            return base + " from " + feed.Title;
                        }
                    }
                } else if (tagOrId.indexOf("tag:") == 0) {
                    var sub = tagOrId.substring("tag:".length);

                    return "Articles from " + sub;
                } else if (!isNaN(tagOrId)) {
                    var feed = (this.feeds || []).filter(function(f) { return f.Id == tagOrId })[0];
                    if (feed) {
                        return feed.Title;
                    }
                }
            },

            _computeHideFeedItems: function(feeds) {
                return this.feeds == 0;
            },

            _computeFavIconUrl: function(feed) {
                this._urlParser.href = feed.Link

                return "//www.google.com/s2/favicons?domain=" + this._urlParser.host;
            },

            _computeNavigationTags: function(tags) {
                return [].concat({name: 'All', feeds: this.feeds}, this.tags);
            },

            _computeNavigationExpandTag: function(item) {
                return 'feeds-' + item.name;
            },

            _computeHideSearchButton: function(tagOrId, searchVisible) {
                return !this._searchAvailable(tagOrId) || searchVisible;
            },

            _computeOptionsMenuSelectedValues: function(userRecord) {
                if (!this.user) {
                    return;
                }

                var selected = [];

                if (this.user.ProfileData.newerFirst) {
                    selected.push("newer-first");
                }

                if (this.user.ProfileData.unreadOnly) {
                    selected.push("unreadOnly");
                }

                return selected;
            },

            _computeReadStateIcon: function(readState) {
                return readState ? 'check-box' : 'check-box-outline-blank';
            },

            _computeHideArticleArrow(articleId, splices, direction) {
                if (direction == 'previous') {
                    return this.articles.findIndex(articleId) > 0 ? "" : "visibility: hidden";
                } else {
                    return this.articles.findIndex(articleId) < this.articles.length ?
                        "" : "visibility: hidden";
                }
            },

            _computeHideEmptyMessage: function(articleRecord, loading) {
                return loading || articleRecord.base.length > 0;
            },


            _computeFeedArticlesArguments: function(userRecord, tagOrId, limit, offset) {
                if (!this.user) {
                    return {};
                }

                return {
                    id: tagOrId,
                    limit: limit,
                    offset: offset,
                    newerFirst: userRecord.base.ProfileData.newerFirst || false,
                    unreadOnly: userRecord.base.ProfileData.unreadOnly || false,
                };
            },

            _extractSearchTokens: function(tagOrId) {
                var parts = tagOrId.split(":"), term, sub;

                if (parts[0] != "search") {
                    return [parts.join(':'), null];
                }

                parts.shift();
                sub = parts[0];

                if (sub == "tag") {
                    sub = parts.splice(0, 2).join(":")
                } else {
                    sub = parts.shift();
                }

                term = decodeURIComponent(parts.join(":"));

                return [sub, term];
            },

            _searchAvailable: function(tagOrId) {
                return tagOrId != 'favorite' &&
                    tagOrId.indexOf('popular:') != 0 &&
                    tagOrId.indexOf('search:') != 0;
            },

            _updateTags: function() {
                var tagList = [], tags = {};

                this.feeds.forEach(function(feed) {
                    if (feed.Tags && feed.Tags.length) {
                        for (var i = 0, tag; tag = feed.Tags[i]; ++i) {
                            if (!tags[tag]) {
                                tags[tag] = [];
                            }

                            tags[tag].push(feed);
                        }
                    }
                });

                Object.keys(tags).sort().forEach(function(tag) {
                    tagList.push({name: tag, feeds: tags[tag]});
                });

                this.tags = tagList;
            },

            _updateArticles: function(delay) {
                if (!this._updateAvailable) {
                    return;
                }

                this.$['feed-articles'].send({
                    id: this.tagOrId,
                    limit: this.limit,
                    offset: 0,
                    newerFirst: this.user.ProfileData.newerFirst || false,
                    unreadOnly: this.user.ProfileData.unreadOnly || false,
                });
            },

            _previousArticle: function(unread) {
                var route = MoreRouting.getRouteByName('article'),
                    article;
                if (route.active) {
                    var index = this.articles.findIndex(route.params.articleId);

                    if (unread) {
                        while (article = this.articles[--index]) {
                            if (!article.Read) {
                                break;
                            }
                        }
                    } else if (index > 0) {
                        article = this.articles[index - 1];
                    }
                } else {
                    if (unread) {
                        var article, index = this.articles.length;
                        while (article = this.articles[--index]) {
                            if (!article.Read) {
                                break;
                            }
                        }
                    } else {
                        article = this.articles[this.articles.length - 1];
                    }
                }

                if (article) {
                    MoreRouting.navigateTo('article', {tagOrId: this.tagOrId, articleId: article.Id});
                }
            },

            _nextArticle: function(unread) {
                var route = MoreRouting.getRouteByName('article'),
                    article;
                if (route.active) {
                    var index = this.articles.findIndex(route.params.articleId);

                    if (unread) {
                        while (article = this.articles[++index]) {
                            if (!article.Read) {
                                break
                            }
                        }
                    } else {
                        article = this.articles[index+1]
                    }
                } else {
                    var index = -1;
                    if (unread) {
                        while (article = this.articles[++index]) {
                            if (!article.Read) {
                                break
                            }
                        }
                    } else {
                        article = this.articles[0];
                    }
                }

                if (article) {
                    MoreRouting.navigateTo('article', {tagOrId: this.tagOrId, articleId: article.Id});
                }
            },

            _markAllAsRead: function() {
                this.$['feed-read-all'].send({id: this.tagOrId, timestamp: this._lastUpdateTime});
            },

            _createArticles: function() {
                var articles = [];

                articles.indexMap = {};
                articles.find = function(id) {
                    return this[this.indexMap[id]];
                };
                articles.findIndex = function(id) {
                    var index = this.indexMap[id];
                    return index === undefined ? -1 : index;
                };

                return articles;
            },

            _handleArticleWorkerMessage: function(event) {
                // Update the map first, the change callbacks might use it
                this.articles.indexMap = event.data.indexMap;

                if (event.data.push.length) {
                    this.push.apply(this, ['articles'].concat(event.data.push));
                }
                if (event.data.unshift.length) {
                    this.unshift.apply(this, ['articles'].concat(event.data.unshift));
                }

                this.loading = false;
                this.$['scroll-threshold'].clearLower();
            },

        })
    </script>
</dom-module>
{% end %}
